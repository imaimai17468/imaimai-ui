{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ios-clock-picker",
  "type": "registry:ui",
  "title": "iOS Clock Picker",
  "description": "An iOS-style 3D cylindrical clock picker with smooth scrolling wheels and drag interactions",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "src/components/registry/ios-clock-picker.tsx",
      "content": "\"use client\";\n\nimport { animate, motion, useMotionValue, useTransform } from \"motion/react\";\nimport { useEffect, useState } from \"react\";\nimport { cn } from \"@/lib/utils\";\n\n/**\n * iOS風時計ピッカーのProps\n */\nexport interface IosClockPickerProps {\n\t/** 選択された時刻 (HH:mm形式) */\n\tvalue: string;\n\t/** 時刻変更時のコールバック */\n\tonChange: (value: string) => void;\n\t/** カスタムクラス名 */\n\tclassName?: string;\n}\n\n/**\n * 単一ホイールのProps\n */\ninterface WheelProps {\n\t/** 表示する項目の配列 */\n\titems: string[];\n\t/** 現在選択されているインデックス */\n\tselectedIndex: number;\n\t/** 選択変更時のコールバック */\n\tonSelect: (index: number) => void;\n\t/** カスタムクラス名 */\n\tclassName?: string;\n\t/** 無限ループを有効化 */\n\tenableInfiniteLoop?: boolean;\n}\n\n/** アイテムの高さ（px） */\nconst ITEM_HEIGHT = 48;\n/** 円筒の半径 - CodePenと同じ */\nconst CYLINDER_RADIUS = 150;\n/** perspective値 - CodePenと同じ */\nconst PERSPECTIVE = 60;\n/** wheelのtranslateZ - CodePenと同じ */\nconst WHEEL_TRANSLATE_Z = 146;\n\n/**\n * スクロールホイールコンポーネント（CodePenと同じアプローチ）\n */\nfunction Wheel({\n\titems,\n\tselectedIndex,\n\tonSelect,\n\tclassName,\n\tenableInfiniteLoop = true,\n}: WheelProps) {\n\tconst itemsLength = items.length;\n\t// 各アイテムの角度（アイテム数に基づく）\n\tconst itemAngle = 360 / itemsLength;\n\n\t// 単一のy値（ドラッグと表示で共通）\n\tconst y = useMotionValue(-selectedIndex * ITEM_HEIGHT);\n\tconst [isDragging, setIsDragging] = useState(false);\n\tconst [startY, setStartY] = useState(0);\n\n\t// y値からrotation角度への変換\n\tconst rotation = useTransform(y, (latest) => {\n\t\tconst index = -latest / ITEM_HEIGHT;\n\t\treturn index * itemAngle;\n\t});\n\n\t// wheelコンテナのtransform文字列\n\tconst wheelTransform = useTransform(rotation, (r) => {\n\t\treturn `translateZ(${WHEEL_TRANSLATE_Z}px) rotateX(${-r}deg)`;\n\t});\n\n\t// 選択インデックスが変わったときにアニメーション\n\tuseEffect(() => {\n\t\tif (!isDragging) {\n\t\t\tconst targetY = -selectedIndex * ITEM_HEIGHT;\n\t\t\tanimate(y, targetY, {\n\t\t\t\ttype: \"spring\",\n\t\t\t\tstiffness: 300,\n\t\t\t\tdamping: 30,\n\t\t\t});\n\t\t}\n\t}, [selectedIndex, y, isDragging]);\n\n\t// ポインターダウン\n\tconst handlePointerDown = (e: React.PointerEvent) => {\n\t\tsetIsDragging(true);\n\t\tsetStartY(e.clientY);\n\t\t(e.target as HTMLElement).setPointerCapture(e.pointerId);\n\t};\n\n\t// ポインタームーブ\n\tconst handlePointerMove = (e: React.PointerEvent) => {\n\t\tif (!isDragging) return;\n\t\tconst deltaY = e.clientY - startY;\n\t\tsetStartY(e.clientY);\n\t\t// 下にドラッグ（正のdeltaY）で数値が増える方向に回転\n\t\ty.set(y.get() - deltaY);\n\t};\n\n\t// ポインターアップ\n\tconst handlePointerUp = () => {\n\t\tif (!isDragging) return;\n\n\t\tconst currentY = y.get();\n\t\tlet index = Math.round(-currentY / ITEM_HEIGHT);\n\n\t\tif (enableInfiniteLoop) {\n\t\t\t// 無限ループ：Modulo演算でインデックスを正規化\n\t\t\tindex = ((index % itemsLength) + itemsLength) % itemsLength;\n\t\t} else {\n\t\t\t// 通常モード：境界内にクランプ\n\t\t\tindex = Math.max(0, Math.min(itemsLength - 1, index));\n\t\t}\n\n\t\t// スナップアニメーション\n\t\tconst targetY = -index * ITEM_HEIGHT;\n\t\tanimate(y, targetY, {\n\t\t\ttype: \"spring\",\n\t\t\tstiffness: 300,\n\t\t\tdamping: 30,\n\t\t});\n\n\t\t// 選択を更新\n\t\tif (index !== selectedIndex) {\n\t\t\tonSelect(index);\n\t\t}\n\n\t\tsetIsDragging(false);\n\t};\n\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\"relative h-64 w-24\", \"touch-none select-none\", className)}\n\t\t\tstyle={{\n\t\t\t\tperspective: `${PERSPECTIVE}px`,\n\t\t\t\tperspectiveOrigin: \"50% 50%\",\n\t\t\t\tclipPath: \"inset(0 0 0 0)\",\n\t\t\t\tmaskImage:\n\t\t\t\t\t\"linear-gradient(transparent, black 20%, black 80%, transparent)\",\n\t\t\t\tWebkitMaskImage:\n\t\t\t\t\t\"linear-gradient(transparent, black 20%, black 80%, transparent)\",\n\t\t\t}}\n\t\t>\n\t\t\t{/* 選択エリアの背景バー */}\n\t\t\t<div className=\"-translate-y-1/2 pointer-events-none absolute top-1/2 right-0 left-0 z-0 h-12 rounded-md bg-muted\" />\n\n\t\t\t{/* Wheelコンテナ（回転するが位置は固定） */}\n\t\t\t<motion.div\n\t\t\t\tclassName=\"pointer-events-none absolute top-1/2 right-0 left-0\"\n\t\t\t\tstyle={{\n\t\t\t\t\theight: `${ITEM_HEIGHT}px`,\n\t\t\t\t\tmarginTop: `-${ITEM_HEIGHT / 2}px`,\n\t\t\t\t\ttransformStyle: \"preserve-3d\",\n\t\t\t\t\ttransform: wheelTransform,\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t{/* すべてのアイテムを固定位置に配置 */}\n\t\t\t\t{items.map((item, index) => {\n\t\t\t\t\t// 回転と一致させるため、indexに直接itemAngleを掛ける\n\t\t\t\t\tconst angle = index * itemAngle;\n\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tkey={`${index}-${item}`}\n\t\t\t\t\t\t\tclassName=\"pointer-events-none absolute inset-0 flex items-center justify-center\"\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\theight: `${ITEM_HEIGHT}px`,\n\t\t\t\t\t\t\t\ttransformStyle: \"preserve-3d\",\n\t\t\t\t\t\t\t\tbackfaceVisibility: \"hidden\",\n\t\t\t\t\t\t\t\ttransform: `rotateX(${angle}deg) translateZ(${-CYLINDER_RADIUS}px)`,\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"font-medium text-lg\">{item}</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</motion.div>\n\n\t\t\t{/* ドラッグ用の透明オーバーレイ */}\n\t\t\t<div\n\t\t\t\tonPointerDown={handlePointerDown}\n\t\t\t\tonPointerMove={handlePointerMove}\n\t\t\t\tonPointerUp={handlePointerUp}\n\t\t\t\tonPointerCancel={handlePointerUp}\n\t\t\t\tclassName=\"absolute inset-0 z-20 cursor-grab active:cursor-grabbing\"\n\t\t\t/>\n\t\t</div>\n\t);\n}\n\n/**\n * iOS風時計ピッカーコンポーネント\n */\nexport function IosClockPicker({\n\tvalue,\n\tonChange,\n\tclassName,\n}: IosClockPickerProps) {\n\t// 時刻をパース\n\tconst [hours, minutes] = value.split(\":\").map(Number);\n\tconst isPM = hours >= 12;\n\n\t// 12時間形式に変換\n\tconst displayHours = hours % 12 || 12;\n\n\t// 各ホイールのデータを生成\n\tconst hourItems = Array.from({ length: 12 }, (_, i) =>\n\t\tString(i + 1).padStart(2, \"0\"),\n\t);\n\tconst minuteItems = Array.from({ length: 60 }, (_, i) =>\n\t\tString(i).padStart(2, \"0\"),\n\t);\n\tconst periodItems = [\"AM\", \"PM\"];\n\n\t// 選択変更ハンドラー\n\tconst handleHourChange = (index: number) => {\n\t\t// index: 0-11, displayHours: 1-12\n\t\tconst newDisplayHours = index + 1;\n\t\t// 24時間形式に変換\n\t\tconst hour24 = isPM\n\t\t\t? newDisplayHours === 12\n\t\t\t\t? 12\n\t\t\t\t: newDisplayHours + 12\n\t\t\t: newDisplayHours === 12\n\t\t\t\t? 0\n\t\t\t\t: newDisplayHours;\n\t\tonChange(\n\t\t\t`${String(hour24).padStart(2, \"0\")}:${String(minutes).padStart(2, \"0\")}`,\n\t\t);\n\t};\n\n\tconst handleMinuteChange = (index: number) => {\n\t\tonChange(\n\t\t\t`${String(hours).padStart(2, \"0\")}:${String(index).padStart(2, \"0\")}`,\n\t\t);\n\t};\n\n\tconst handlePeriodChange = (index: number) => {\n\t\tconst newIsPM = index === 1;\n\t\tconst newHours = newIsPM\n\t\t\t? displayHours === 12\n\t\t\t\t? 12\n\t\t\t\t: displayHours + 12\n\t\t\t: displayHours === 12\n\t\t\t\t? 0\n\t\t\t\t: displayHours;\n\t\tonChange(\n\t\t\t`${String(newHours).padStart(2, \"0\")}:${String(minutes).padStart(2, \"0\")}`,\n\t\t);\n\t};\n\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t\"relative inline-flex items-center justify-center gap-0.5\",\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t>\n\t\t\t{/* 時 */}\n\t\t\t<Wheel\n\t\t\t\titems={hourItems}\n\t\t\t\tselectedIndex={displayHours - 1}\n\t\t\t\tonSelect={handleHourChange}\n\t\t\t\tenableInfiniteLoop={true}\n\t\t\t/>\n\n\t\t\t{/* 分 */}\n\t\t\t<Wheel\n\t\t\t\titems={minuteItems}\n\t\t\t\tselectedIndex={minutes}\n\t\t\t\tonSelect={handleMinuteChange}\n\t\t\t\tenableInfiniteLoop={true}\n\t\t\t/>\n\n\t\t\t{/* AM/PM */}\n\t\t\t<Wheel\n\t\t\t\titems={periodItems}\n\t\t\t\tselectedIndex={isPM ? 1 : 0}\n\t\t\t\tonSelect={handlePeriodChange}\n\t\t\t\tclassName=\"w-20\"\n\t\t\t\tenableInfiniteLoop={true}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n",
      "type": "registry:component"
    }
  ]
}