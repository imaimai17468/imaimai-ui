{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ellipsis-pagination",
  "type": "registry:ui",
  "title": "Ellipsis Pagination",
  "description": "A pagination component that automatically truncates page numbers with ellipsis when there are many pages",
  "registryDependencies": [
    "pagination"
  ],
  "files": [
    {
      "path": "src/components/registry/ellipsis-pagination.tsx",
      "content": "\"use client\";\n\nimport {\n\tPagination,\n\tPaginationContent,\n\tPaginationEllipsis,\n\tPaginationItem,\n\tPaginationLink,\n\tPaginationNext,\n\tPaginationPrevious,\n} from \"@/components/ui/pagination\";\n\nexport interface EllipsisPaginationProps {\n\t/** 現在のページ（1-indexed） */\n\tcurrentPage: number;\n\t/** 総ページ数 */\n\ttotalPages: number;\n\t/** ページ変更時のコールバック */\n\tonPageChange: (page: number) => void;\n\t/** 現在ページの前後に表示するページ数 */\n\tsiblingCount?: number;\n\t/** 最初と最後に表示するページ数 */\n\tboundaryCount?: number;\n}\n\ntype PageItem =\n\t| { type: \"page\"; value: number }\n\t| { type: \"ellipsis\"; id: string };\n\n/**\n * ページ番号の配列を生成する\n * 例: generatePageNumbers(50, 100, 1, 1) => [1, null, 49, 50, 51, null, 100]\n *     null は省略記号（...）を表す\n */\nfunction generatePageNumbers(\n\tcurrentPage: number,\n\ttotalPages: number,\n\tsiblingCount: number,\n\tboundaryCount: number,\n): PageItem[] {\n\t// 総ページ数が少ない場合は全て表示\n\tconst totalNumbers = siblingCount * 2 + 1 + boundaryCount * 2 + 2; // +2 は省略記号の最大数\n\tif (totalPages <= totalNumbers) {\n\t\treturn Array.from({ length: totalPages }, (_, i) => ({\n\t\t\ttype: \"page\",\n\t\t\tvalue: i + 1,\n\t\t}));\n\t}\n\n\t// 最初と最後のページ番号\n\tconst firstPages = Array.from({ length: boundaryCount }, (_, i) => ({\n\t\ttype: \"page\" as const,\n\t\tvalue: i + 1,\n\t}));\n\tconst lastPages = Array.from({ length: boundaryCount }, (_, i) => ({\n\t\ttype: \"page\" as const,\n\t\tvalue: totalPages - boundaryCount + i + 1,\n\t}));\n\n\t// 現在ページ周辺のページ番号の初期計算\n\tlet startPage = Math.max(boundaryCount + 1, currentPage - siblingCount);\n\tlet endPage = Math.min(\n\t\ttotalPages - boundaryCount,\n\t\tcurrentPage + siblingCount,\n\t);\n\n\t// 左側にellipsisがない場合は、endPageを広げる\n\tif (startPage <= boundaryCount + 1) {\n\t\tendPage = Math.min(\n\t\t\ttotalPages - boundaryCount,\n\t\t\tboundaryCount + 1 + siblingCount,\n\t\t);\n\t}\n\n\t// 右側にellipsisがない場合は、startPageを下げてendPageを広げる\n\tif (endPage >= totalPages - boundaryCount - 1) {\n\t\tstartPage = Math.max(\n\t\t\tboundaryCount + 1,\n\t\t\ttotalPages - boundaryCount - siblingCount * 2 - 1,\n\t\t);\n\t\tendPage = totalPages - boundaryCount;\n\t}\n\n\t// middlePagesを生成（firstPages/lastPagesと重複しない範囲）\n\tconst middlePages: PageItem[] = [];\n\tfor (let i = startPage; i <= endPage; i++) {\n\t\t// boundaryCountの範囲と重複しないページのみ追加\n\t\tif (i > boundaryCount && i <= totalPages - boundaryCount) {\n\t\t\tmiddlePages.push({\n\t\t\t\ttype: \"page\" as const,\n\t\t\t\tvalue: i,\n\t\t\t});\n\t\t}\n\t}\n\n\t// 省略記号が必要か判定\n\tconst hasLeftEllipsis = startPage > boundaryCount + 1;\n\tconst hasRightEllipsis = endPage < totalPages - boundaryCount;\n\n\t// ページ番号配列を構築\n\tconst pages: PageItem[] = [...firstPages];\n\n\tif (hasLeftEllipsis) {\n\t\tpages.push({ type: \"ellipsis\", id: \"left\" }); // 省略記号\n\t}\n\n\tpages.push(...middlePages);\n\n\tif (hasRightEllipsis) {\n\t\tpages.push({ type: \"ellipsis\", id: \"right\" }); // 省略記号\n\t}\n\n\tpages.push(...lastPages);\n\n\treturn pages;\n}\n\n/**\n * ページ数が多い時に自動的に省略記号（...）を表示するPaginationコンポーネント\n *\n * @example\n * ```tsx\n * <EllipsisPagination\n *   currentPage={5}\n *   totalPages={100}\n *   onPageChange={(page) => console.log(page)}\n *   siblingCount={1}\n *   boundaryCount={1}\n * />\n * ```\n */\nexport function EllipsisPagination({\n\tcurrentPage,\n\ttotalPages,\n\tonPageChange,\n\tsiblingCount = 1,\n\tboundaryCount = 1,\n}: EllipsisPaginationProps) {\n\tconst pages = generatePageNumbers(\n\t\tcurrentPage,\n\t\ttotalPages,\n\t\tsiblingCount,\n\t\tboundaryCount,\n\t);\n\n\tconst handlePrevious = () => {\n\t\tif (currentPage > 1) {\n\t\t\tonPageChange(currentPage - 1);\n\t\t}\n\t};\n\n\tconst handleNext = () => {\n\t\tif (currentPage < totalPages) {\n\t\t\tonPageChange(currentPage + 1);\n\t\t}\n\t};\n\n\treturn (\n\t\t<Pagination>\n\t\t\t<PaginationContent>\n\t\t\t\t{/* 前へボタン */}\n\t\t\t\t<PaginationItem>\n\t\t\t\t\t<PaginationPrevious\n\t\t\t\t\t\tonClick={handlePrevious}\n\t\t\t\t\t\taria-disabled={currentPage === 1}\n\t\t\t\t\t\tclassName={\n\t\t\t\t\t\t\tcurrentPage === 1 ? \"pointer-events-none opacity-50\" : \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t</PaginationItem>\n\n\t\t\t\t{/* ページ番号 */}\n\t\t\t\t{pages.map((item) => (\n\t\t\t\t\t<PaginationItem\n\t\t\t\t\t\tkey={\n\t\t\t\t\t\t\titem.type === \"page\"\n\t\t\t\t\t\t\t\t? `page-${item.value}`\n\t\t\t\t\t\t\t\t: `ellipsis-${item.id}`\n\t\t\t\t\t\t}\n\t\t\t\t\t>\n\t\t\t\t\t\t{item.type === \"ellipsis\" ? (\n\t\t\t\t\t\t\t<PaginationEllipsis />\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<PaginationLink\n\t\t\t\t\t\t\t\tonClick={() => onPageChange(item.value)}\n\t\t\t\t\t\t\t\tisActive={item.value === currentPage}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{item.value}\n\t\t\t\t\t\t\t</PaginationLink>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</PaginationItem>\n\t\t\t\t))}\n\n\t\t\t\t{/* 次へボタン */}\n\t\t\t\t<PaginationItem>\n\t\t\t\t\t<PaginationNext\n\t\t\t\t\t\tonClick={handleNext}\n\t\t\t\t\t\taria-disabled={currentPage === totalPages}\n\t\t\t\t\t\tclassName={\n\t\t\t\t\t\t\tcurrentPage === totalPages ? \"pointer-events-none opacity-50\" : \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t/>\n\t\t\t\t</PaginationItem>\n\t\t\t</PaginationContent>\n\t\t</Pagination>\n\t);\n}\n",
      "type": "registry:component"
    }
  ]
}